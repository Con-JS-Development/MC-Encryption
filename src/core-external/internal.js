import * as m from "@minecraft/server";
const charCodeAt=String.call.bind(String.prototype.charCodeAt),fromCharCode=String.fromCharCode;class EK{constructor(e,t=3e3){this.cryptionKey=e??2,this.type=typeof e,this.base=t}coreSet(e,t){return"number"==this.type?this.base+e*this.cryptionKey+t:"string"==this.type?this.base+e*(charCodeAt(this.cryptionKey,t%this.cryptionKey.length)+1)+t%this.cryptionKey.length:void 0}coreGet(e,t){return"number"==this.type?(e-this.base-t)/this.cryptionKey:"string"==this.type?(e-this.base-t%this.cryptionKey.length)/(charCodeAt(this.cryptionKey,t%this.cryptionKey.length)+1):void 0}*decrypt(e){for(let t=0;t<e.length;t++)yield this.coreSet(charCodeAt(e,t),t)}*encrypt(e){for(let t=0;t<e.length;t++)yield this.coreGet(charCodeAt(e,t),t)}}class Coder{static Code(e,t){return fromCharCode(...t.decrypt(e))}static Decode(e,t){return fromCharCode(...t.encrypt(e))}}class EM{constructor(e,t=new Path(""),r=e=>{throw ReferenceError("Module "+e+"doesn't exist.")}){this.isEvaluted=!1,this.module=void 0,this.encrypt_code=e,this.path=t,this.moduleRequire=r}setPathAssign(e){this.path=e}encrypt(e){this.code=Coder.Decode(this.encrypt_code,e)}execute(e){e&&this.encrypt(e);let t=this.buildFunction();delete this.code,delete this.encrypt_code;let r={},i={get exports(){return r},set exports(ex){r=ex}};return pE(i),t(this.require.bind(this,e),i),this.module=r??{},r??{}}importModule(e){return this.module??this.execute(e)}require(e,t){if("string"!=typeof t)throw TypeError("path must be a string.");if(t.length<1)throw TypeError("Invalid path '"+t+"'.");try{var r=this.path.relitiveTo(t)}catch(i){}return this.moduleRequire(t,r??void 0,e)}buildFunction(){return EM.native_compiler("require","module","propertyRegister",this.code)}}EM.native_compiler=Function;class Path{constructor(e){this.paths=e.split("/")}get folderPaths(){if(this.paths.length<2)return[];let e=[...this.paths];return e.pop(),e}relitiveTo(e){let t=e.split("/");if("."!==t[0]&&".."!==t[0])return Path.fromArray(t);let r=this.folderPaths;if("."==t[0])t.shift();else if(".."==t[0])for(let i of[...t]){if(".."==i){if(r.length<1)throw SyntaxError("Invalid relative path provided");t.shift(),r.pop()}break}return Path.fromArray([...r,...t])}static fromArray(e){let t=Object.create(Path.prototype);return t.paths=e,t}toString(){return this.paths.join("/")}valueOf(){return this.toString()}}const{preventExtensions:pE,getOwnPropertyNames:gN}=Object;function module_require(e,t,r){if(external_modules[e])return external_modules[e];if(void 0==t)throw ReferenceError("Module not found ["+e+"]");let i=t.toString(),o=gN(encrypted_modules).find(e=>e===i||e===i+".js");if(o)return encrypted_modules[o].importModule(r);throw ReferenceError("Module not found ["+e+"]")}
const{setDynamicProperty:sD,getDynamicProperty:gD}=m.world;m.system.afterEvents.scriptEventReceive.subscribe(({sourceEntity:e,message:t,id:r})=>{if("encryption:key"===r&&key_lock)(sD.call(m.world,"encrytion_key",t),console.warn("New encryption key defined, use /reload to reload engine session with new encryption key")); else if ("encryption:unlock"===r&&e&&name_lock) (sD.call(m.world,"encrytion_key",e.name),console.warn("New encryption key defined, use /reload to reload engine session with new encryption key"))},{namespaces:["encryption"]}),m.world.afterEvents.worldInitialize.subscribe(({propertyRegistry:e})=>{e.registerWorldDynamicProperties(new m.DynamicPropertiesDefinition().defineString("encrytion_key",255)),globalThis.propertyRegistry=e,console.warn("Key:"+gD.call(m.world,"encrytion_key")),encrypted_modules[entry].importModule(new EK(gD.call(m.world,"encrytion_key"))),delete globalThis.propertyRegistry});